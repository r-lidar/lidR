% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_canopy.r
\name{grid_canopy}
\alias{grid_canopy}
\title{Canopy surface model}
\usage{
grid_canopy(las, res = 2, subcircle = 0, ...)
}
\arguments{
\item{las}{An object of class \code{LAS} or \code{LAScatalog}.}

\item{res}{numeric. The size of a grid cell in LiDAR data coordinates units. Default is
2 meters i.e. 4 square meters.}

\item{subcircle}{numeric. radius of the circles. To obtain fewer empty pixels the algorithm
can replace each return with a circle composed of 8 points (see details).}

\item{...}{extra parameters for the algorithm used to interpolate the empty pixels (see details)}

\item{na.fill}{character. name of the algorithm used to interpolate the data and fill the empty pixels.
Can be \code{"knnidw"}, \code{"delaunay"} or \code{"kriging"} (see details).}

\item{filter}{character. Streaming filter while reading the files (see \link{readLAS}).
If \code{x} is a \code{LAScatalog} the function \link{readLAS} is called internally. The
user cannot manipulate the lidar data directly but can use streaming filters instead.}
}
\value{
Returns a \code{data.table} of class \code{lasmetrics}, which enables easier
plotting and RasterLayer casting.
}
\description{
Creates a canopy surface model using a LiDAR point cloud. For each pixel the function
returns the highest point found (point-to-raster). This basic method could be improved
by replacing each LiDAR return with a small disc. An interpolation for empty pixels is
also available.
}
\details{
The algorithm relies on a point-to-raster approach. For each pixel the elevation of the
highest point is found and attributed to this pixel. This method implies that the resulting
surface model can contain empty pixels. Those 'holes' can be filled by interpolation.
Internally, the interpolation is based on the same method used in the function
\link[lidR:grid_terrain]{grid_terrain}. Therefore the documentation for
\link[lidR:grid_terrain]{grid_terrain} is also applicable to this function (see also
examples).\cr\cr
The 'subcircle' tweak replaces each point with 8 points around the original one. This allows
for virtual 'emulation' of the fact that a lidar point is not a point as such, but more
realistically a disc. This tweak densifies the point cloud and the resulting canopy model is
smoother and contains fewer 'pits' and empty pixels.
}
\section{Working with a \code{LAScatalog}}{

In \code{lidR} when the input is a \link[lidR:LAScatalog-class]{LAScatalog} the functions run following
the catalog processing options. The user can modify the processing options using the
\link[lidR:catalog]{available options}.\cr\cr
\code{lidR} supports .lax files that \strong{significantly} improve the computation speed of
spatial queries using a spatial index. Users should really take advange a .lax files but this is
not mandatory.
}

\examples{
LASfile <- system.file("extdata", "Megaplot.laz", package="lidR")
lidar = readLAS(LASfile)

# Local maximum algorithm with a resolution of 2 meters
chm = grid_canopy(lidar, 2)
plot(chm)

# Local maximum algorithm with a resolution of 1 meter replacing each
# point by a 20 cm radius circle of 8 points
chm = grid_canopy(lidar, 1, 0.2)
plot(chm)

# Local maximum algorithm with a resolution of 1 meter replacing each
# point by a 10 cm radius circle of 8 points and interpolating the empty
# pixels using the 3-nearest neighbours and an inverse-distance weighting.
chm = grid_canopy (lidar, 1, subcircle = 0.1, na.fill = "knnidw", k = 3, p = 2)
plot(chm)

\dontrun{
chm = grid_canopy(lidar, 1, na.fill = "knnidw", k = 3)
plot(chm)
chm = grid_canopy(lidar, 1, subcircle = 0.1, na.fill = "delaunay")
plot(chm)
}
}
\seealso{
\link[lidR:grid_metrics]{grid_metrics}
}

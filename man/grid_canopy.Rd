% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_canopy.r
\name{grid_canopy}
\alias{grid_canopy}
\title{Digital Surface Model}
\usage{
grid_canopy(las, res, algorithm)
}
\arguments{
\item{las}{An object of class \link[lidR:LAS-class]{LAS} or \link[lidR:LAScatalog-class]{LAScatalog}.}

\item{res}{numeric. The resolution of the output \code{Raster}. Can optionnaly be a \code{RasterLayer}.
In that case the the \code{RasterLayer} is used as layout.}

\item{algorithm}{function. A function that implements an algorithm to compute a digital surface model.
\code{lidR} have \link{p2r}, \link{dsmtin}, \link{pitfree} (see respective documentations and exemples).}
}
\value{
A \code{RasterLayer} containing a numeric value in each cell. If the \code{RasterLayer}s
are written on disk when running the function with a \code{LAScatalog}, a virtual raster mosaic is
returned (see \link[gdalUtils:gdalbuildvrt]{gdalbuildvrt})
}
\description{
Creates a digital surface model using several possible algorithms.
}
\section{Working with a \code{LAScatalog}}{

This section appears in each function that supports a LAScatalog as input.\cr

In \code{lidR} when the input of a function is a \link[lidR:LAScatalog-class]{LAScatalog} the
functions uses the LAScatalog processing engine. The user can modify the engine options using
the \link[lidR:catalog_options_tools]{available options}. A careful read of the
\link[lidR:LAScatalog-class]{engine documentation} is recommended to process \code{LAScatalogs}. Each
\code{lidR} function should come with a section that document the supported engine options.\cr

\code{LAScatalog} engine supports \code{.lax} files that \emph{significantly} improve the computation
speed of spatial queries using a spatial index. Users should really take advange a \code{.lax} files
but this is not mandatory.
}

\section{Supported processing options}{

Supported processing options for a \code{LAScatalog} in \code{grid_*} functions (in bold). For
more details see the \link[lidR:LAScatalog-class]{LAScatalog engine documentation}:
\itemize{
\item \strong{tiling_size}: How much data are loaded at once. The tiling size may be slightly modified
internally to ensure a strict continuous wall-to-wall output even when tiling size equal to 0 (processing
by file).
\item buffer: This function guarantee a strict continuous wall-to-wall output. The \code{buffer} option
is no considered.
\item \strong{alignment}: Align the processed clusters. The alignment may be slightly modified
internally to ensure a strict continuous wall-to-wall output.
\item \strong{cores}: How many cores are used.
\item \strong{progress}: Displays a progression estimation.
\item \strong{output_files}: Return the output in R or write each cluster's output in a file. Supported
templates are \code{XLEFT}, \code{XRIGHT}, \code{YBOTTOM}, \code{YTOP}, \code{XCENTER}, \code{YCENTER}
\code{ID} and, if tiling size equal to 0 (processing by file), \code{ORIGINALFILENAME}.
\item laz_compression: is not supported because this function will never write \code{las/laz} files
\item \strong{\emph{select}}: The functions \code{grid_*} usually know for you what should be loaded or not
and this options is not considered. In \link{grid_metrics} this option is respected.
\item \strong{filter}: Read only points of interest.
}
}

\examples{
LASfile <- system.file("extdata", "MixedConifer.laz", package="lidR")
las <- readLAS(LASfile)
col <- height.colors(50)

# Points-to-raster algorithm with a resolution of 1 meters
chm <- grid_canopy(las, res = 1, p2r())
plot(chm, col = col)

# Points-to-raster algorithm with a resolution of 0.5 meter replacing each
# point by a 20 cm radius circle of 8 points
chm <- grid_canopy(las, res = 0.5, p2r(0.2))
plot(chm, col = col)

# Basic triangulation and rasterization of first returns
chm <- grid_canopy(las, res = 0.5, dsmtin())
plot(chm, col = col)

# Khosravipour et al. pitfree algorithm
chm <- grid_canopy(las, res = 0.5, pitfree(c(0,2,5,10,15), c(0, 1.5)))
plot(chm, col = col)
}

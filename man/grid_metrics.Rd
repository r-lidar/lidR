% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_metrics.r
\name{grid_metrics}
\alias{grid_metrics}
\title{Area Based Approach}
\usage{
grid_metrics(las, func, res = 20, start = c(0, 0), ...)
}
\arguments{
\item{las}{An object of class \code{LAS} or \code{LAScatalog}.}

\item{func}{the function to be applied to each cell (see section "Parameter func")}

\item{res}{numeric. The size of the cells. Default 20.}

\item{start}{vector x and y coordinates for the reference raster. Default is (0,0) meaning that the
grid aligns on (0,0).}

\item{...}{Additional argument for \link{readLAS} to reduce the amount of data loaded (only with a
\code{LAScatalog} object)}
}
\value{
A \code{RasterLayer} or a \code{RasterBrick} containing the metrics for each cell.
}
\description{
Computes a series of user-defined descriptive statistics for a LiDAR dataset within
each pixel of a raster (area-based approach). The grid cell coordinates are pre-determined for a
given resolution, so the algorithm will always provide the same coordinates independently of the
dataset. When start = (0,0) and res = 20 grid_metrics will produce the following cell centers:
(10,10), (10,30), (30,10) etc. aligning the corner of a cell on (0,0). When start = (-10, -10) and
res = 20' grid_metrics will produce the following cell centers: (0,0), (0,20), (20,0) etc. aligning
the corner of a cell on (-10, -10).
}
\section{Parameter \code{func}}{

The function to be applied to each cell is a classical function (see examples) that
returns a labelled list of metrics. For exemple the following function \code{f} is correctly formed.
\preformatted{
f = function(x) {list(mean = mean(x), max = max(x))}
}
And could be applied either on the \code{Z} coordinates or the Intensities for exemples. These two
statements are valid:
\preformatted{
grid_metrics(las, f(Z), res = 20)
grid_metrics(las, f(Intensity), res = 20)
}
The following existing functions allow the user to
compute some predefined metrics:
\itemize{
\item{\link[lidR:stdmetrics]{stdmetrics}}
\item{\link[lidR:entropy]{entropy}}
\item{\link[lidR:VCI]{VCI}}
\item{\link[lidR:LAD]{LAD}}
}
But usually the users must write their own functions to create metrics. \code{grid_metrics} will
dispatch the point cloud in the user's function.
}

\section{Working with a \code{LAScatalog}}{

In \code{lidR} when the input is a \link[lidR:LAScatalog-class]{LAScatalog} the functions run following
the catalog processing options. The user can modify the processing options using the
\link[lidR:catalog]{available options}.\cr\cr
\code{lidR} supports .lax files that \strong{significantly} improve the computation speed of
spatial queries using a spatial index. Users should really take advange a .lax files but this is
not mandatory.
}

\section{Supported processing options for a LAScatalog}{

\itemize{
\item \strong{cores}: See \link{LAScatalog-class}.
\item \strong{progress}: See \link{LAScatalog-class}.
\item \strong{stop_early}: See \link{LAScatalog-class}.
\item \strong{tiling_size}: See \link{LAScatalog-class}.
}
}

\examples{
LASfile <- system.file("extdata", "Megaplot.laz", package="lidR")
lidar = readLAS(LASfile)

# Canopy surface model with 4 m^2 cells
metrics = grid_metrics(lidar, max(Z), 2)
plot(metrics)

# Mean height with 400 m^2 cells
metrics = grid_metrics(lidar, mean(Z), 20)
plot(metrics)

# Define your own new metrics
myMetrics = function(z, i)
{
  metrics = list(
     zwimean = sum(z*i)/sum(i), # Mean elevation weighted by intensities
     zimean  = mean(z*i),       # Mean products of z by intensity
     zsqmean = sqrt(mean(z^2))  # Quadratic mean
   )

   return(metrics)
}

metrics = grid_metrics(lidar, myMetrics(Z, Intensity))

plot(metrics)
plot(metrics, "zwimean")
plot(metrics, "zimean")
plot(metrics, "zsqmean")
}

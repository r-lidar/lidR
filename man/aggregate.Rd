% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metrics_cloud.R, R/metrics_crowns.R,
%   R/metrics_hexagons.R, R/metrics_pixels.R, R/metrics_plot.R,
%   R/metrics_polygon.R, R/metrics_template.R, R/metrics_voxels.R
\name{cloud_metrics}
\alias{cloud_metrics}
\alias{crown_metrics}
\alias{hexagon_metrics}
\alias{pixel_metrics}
\alias{plot_metrics}
\alias{polygon_metrics}
\alias{aggregate}
\alias{template_metrics}
\alias{voxel_metrics}
\title{Metric derivation at different levels of regularization}
\usage{
cloud_metrics(las, func, ...)

crown_metrics(
  las,
  func,
  geom = "point",
  concaveman = c(3, 0),
  attribute = "treeID",
  ...
)

hexagon_metrics(las, func, area = 400, ...)

pixel_metrics(las, func, res = 20, start = c(0, 0), ...)

plot_metrics(las, func, geometry, ..., radius)

polygon_metrics(las, func, geometry, ...)

template_metrics(las, func, template, filter = NULL, by_echo = "all", ...)

voxel_metrics(las, func, res = 1, ..., all_voxels = FALSE)
}
\arguments{
\item{las}{An object of class \link[lidR:LAS-class]{LAS} or \link[lidR:LAScatalog-class]{LAScatalog}.}

\item{func}{formula. An expression to be applied to each element of the template (see section
"Parameter func").}

\item{...}{propagated to \code{template_metrics} i.e. \code{filter} and \code{by_echo}. \code{pixel_metrics()} also
supports \code{pkg = "terra|raster|stars"} to get an output in format \code{SpatRaster}, \code{RasterLayer}
or \code{stars}. Default is \code{getOption("lidR.raster.default")}. Under the hood lidR uses native pkg code
and does not cast to pkg.}

\item{geom}{character. geometry type of the output. Can be 'point', 'convex', 'concave' or 'bbox'.}

\item{concaveman}{numeric. Only if \code{type = "concave"}. Vector with the two parameters of the
function \link{concaveman}.}

\item{attribute}{character. The column name of the attribute containing tree IDs. Default is
\code{"treeID"}}

\item{area}{numeric. Area of the hexagons}

\item{res}{numeric. The resolution of the output. Can optionally be a `RasterLayer` or a `stars`
In that case the raster is used as the template.}

\item{start}{vector of x and y coordinates for the reference raster. Default is (0,0) meaning that the
grid aligns on (0,0). Not consiered if `res` is a raster}

\item{geometry}{a spatial vector object. `sp` and `sf`' objects are supported}

\item{radius}{numeric. If the geometry is spatial points as radius must be defined}

\item{template}{can be of many types and correspond to the different levels of regularization.
\code{RasterLayer}, \code{stars}, \code{sf/sfc} (polygons), \code{numeric}, \code{bbox}. The metrics
are computed for each element of the template. See examples}

\item{filter}{formula of logical predicates. Enables the function to run only on points of interest
in an optimized way. See examples.}

\item{by_echo}{characters. The metrics are computed multiples times for different echo types. Can
be one or more of "all", "first", "intermediate", "lastofmany", "single", "multiple". See examples.
Default is "all" meaning that it computes metrics with all points provided.}

\item{all_voxels}{boolean. By default the function returns only voxels that
contain 1 or more points. Empty voxels do not exist as the metrics are undefined.
If \code{all_voxels = TRUE} all the voxels are returned and metrics are NA for
voxels with 0 points.}
}
\value{
Depends on the function, the template and the number of metrics. Can be a \code{RasterLayer},
a \code{RasterBrick}, a \code{stars}, an \code{sf/sfc}, a \code{list}, a \code{SpatialPolygonDataFrame}, a \code{data.table}.
Functions are supposed to return an object that best suit for storing the level of regularization
asked.
}
\description{
\code{template_metrics()} computes a series of user-defined descriptive statistics for a LiDAR dataset within
each element of a template. Depending on the template it can be for each pixel of a raster
(area-based approach) or each polygon, or each segmented tree or on the whole point cloud. Other
functions are convenient and simplified wrappers around \code{template_metrics()}. See Details and Examples.
}
\details{
\describe{
\item{\code{pixel_metrics}}{For area-based approach. Computes metrics in an square tessellation.}
\item{\code{hexagon_metrics}}{Computes metrics in an hexagon tessellation.}
\item{\code{plot_metrics}}{Computes metrics for each plot of a ground inventory by 1. clipping the plots
inventories 2. computing user's metrics to each plot 3. combining spatial data and metrics into
one data.frame ready for statistical modelling. \code{plot_metrics} is basically a seamless wrapper
around \link{clip_roi}, \link{cloud_metrics}, \code{cbind} and adequate processing settings.}
\item{\code{cloud_metrics}}{Computes a series of user-defined descriptive statistics for an entire dataset.}
\item{\code{crown_metrics}}{Once the trees are segmented, i.e. attributes exist in the
point cloud that reference each tree, computes a set of user-defined descriptive statistics for
each individual tree. The output can be spatial point or spatial polygons.}
\item{\code{voxel_metrics}}{Is a 3D version of \code{pixel_metrics}. It creates a 3D matrix of voxels with a given
resolution. It creates a voxel from the cloud of points if there is at least one point.}
\item{\code{point_metrics}}{Is a bit more complex and is documented in \link{point_metrics}}
}
}
\section{Parameter \code{func}}{

The function to be applied to each cell is a classical function (see examples) that
returns a labelled list of metrics. For example, the following function \code{f} is correctly formed.
\preformatted{
f = function(x) {list(mean = mean(x), max = max(x))}
}
And could be applied either on the \code{Z} coordinates or on the intensities. These two
statements are valid:
\preformatted{
pixel_metrics(las, ~f(Z), res = 20)
voxel_metrics(las, ~f(Intensity), res = 2)
}
The following existing functions allow the user to
compute some predefined metrics: \link[=stdmetrics]{stdmetrics}
\link[=entropy]{entropy} \link[=VCI]{VCI} \link[=LAD]{LAD}. But usually users must write their own
functions to create metrics. \code{template_metrics} will dispatch the point cloud in the user's
function.
}

\examples{
LASfile <- system.file("extdata", "Megaplot.laz", package="lidR")
las = readLAS(LASfile, filter = "-keep_random_fraction 0.5")
col = sf::sf.colors(15)

# === Using a generic template ====

fun <- ~list(maxz = max(Z))

template <- raster::raster(extent(las), nrow = 15, ncol = 15)
raster::crs(template) <- crs(las)
m = template_metrics(las, fun, template)
plot(m, col = col)

sfc = sf::st_as_sfc(st_bbox(las))
template = sf::st_make_grid(sfc, cellsize = 10, square = FALSE)
m = template_metrics(las, fun, template)
plot(m, nbreaks = 15)

template = st_bbox(las) + c(50,30,-50,-70)
plot(sf::st_as_sfc(st_bbox(las)), col = "gray")
plot(sf::st_as_sfc(template), col = "darkgreen", add = TRUE)
m = template_metrics(las, fun, template)
print(m)

# === Define your own new metrics ===

myMetrics = function(z, i) {
  metrics = list(
     zwimean = sum(z*i)/sum(i), # Mean elevation weighted by intensities
     zimean  = mean(z*i),       # Mean products of z by intensity
     zsqmean = sqrt(mean(z^2))) # Quadratic mean

   return(metrics)
}

template <- stars::st_as_stars(st_bbox(las), nx = 18, ny = 18)
m = template_metrics(las, ~myMetrics(Z, Intensity), template)
plot(m, col = col, breaks = "equal", join_zlim = FALSE)

# === Entire point cloud ====

cloud_metrics(las, .stdmetrics_z)

# === Area-based approach ===

m = pixel_metrics(las, fun, 20)
plot(m, col = col, breaks = "equal")

m = pixel_metrics(las, ~myMetrics(Z, Intensity))
plot(m, col = col)

# === Ground inventory ====

shpfile <- system.file("extdata", "efi_plot.shp", package="lidR")
inventory <- sf::st_read(shpfile, quiet = TRUE)
inventory # contains an ID and a Value Of Interest (VOI) per plot
fun = ~list(q85 = quantile(Z, probs = 0.85))

m <- plot_metrics(las, fun, inventory, radius = 11.28)
plot(m["q85"], pch = 19, cex = 3)

\donttest{
# Works with polygons as well
inventory <- sf::st_buffer(inventory, 11.28)
plot(las@header)
plot(sf::st_geometry(inventory), add = TRUE)
m <- plot_metrics(las, .stdmetrics_z, inventory)
plot(m["zq85"], pch = 19, cex = 3)
}

# === Voxels based product

m <- voxel_metrics(las, ~length(Z), 8)
m <- voxel_metrics(las, ~mean(Intensity), 8)
#plot(m, color = "V1", colorPalette = heat.colors(50), trim = 60)
#plot(m, color = "V1", colorPalette = heat.colors(50), trim = 60, voxel = TRUE)

# === Crown based metrics ====

LASfile <- system.file("extdata", "MixedConifer.laz", package="lidR")
las <- readLAS(LASfile, filter = "-drop_z_below 0")

metrics <- crown_metrics(las, .stdtreemetrics)
plot(metrics["Z"])

metrics <- crown_metrics(las, .stdtreemetrics, geom = "convex")
plot(metrics["Z"])

metrics <- crown_metrics(las, .stdtreemetrics, geom = "bbox")
plot(metrics["Z"])

\donttest{
metrics <- crown_metrics(las, .stdtreemetrics, geom = "concave")
plot(metrics["Z"])
}

# === With point filters ===

# Compute using only some points: basic
first = filter_poi(las, ReturnNumber == 1)
metrics = pixel_metrics(first, ~mean(Z), 20)

# Compute using only some points: optimized
# faster and uses less memory. No intermediate object
metrics = pixel_metrics(las, ~mean(Z), 20, filter = ~ReturnNumber == 1)

# Compute using only some points: best
# ~50\% faster and uses ~10x less memory
las = readLAS(LASfile, filter = "-keep_first")
metrics = pixel_metrics(las, ~mean(Z), 20)

# === Split by echo type ===

func = ~list(avgI = mean(Intensity))
echo = c("all", "first","multiple")

metrics <- pixel_metrics(las, func, 20, by_echo = echo)
plot(metrics, col = heat.colors(25))

cloud_metrics(las, func, by_echo = echo)

}
